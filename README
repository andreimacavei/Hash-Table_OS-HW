Tema1 - Sistem de Operare
Macavei Andrei Gabriel
334 CB

Tema este impartita in mai multe fisiere sursa deoarece am incercat sa modularizez codul astfel incat sa am functiile "cu acelasi scop" in fisiere separate (ie: toate functiile ce lucreaza pe lista intr-un fisier).

- main.c : principala bucla a programului in care citesc / scriu in fisier

- hash.c, hash.h : fisierele ce descriu o structura de tabel de dispersie impreuna cu functii folosite pentru operatii de: 
	-initializare, 
	-adaugare in tabela,
	-stergere din tabela,
	-cautare in tabela,
	-golire tabela,
	-afisare tabela,
	-redimensionare tabela,
	-eliberare resurse tabela

- list.c, list.h : fisierele ce descriu o structura de lista simplu inlantuita impreuna cu functii folosite (asemanator cu tabela de dispersie).

- utils.h : contine macro-uri folosite pentru detectia si afisarea erorilor la stderr

Table de dispersia este reprezentata de o structura cu 2 componente: 
-buckets: o lista de liste simplu inlantuite
-size: dimensiunea tabele

Fiecare bucket este o lista simplu intalntuita iar primul nod din lista este un nod santinela ce nu contine date ci doar legatura catre nodul urmator sau null daca lista este goala.

Lista este reprezentata folosind 2 pointeri, un pointer head pentru santinela si un pointer tail pentru ultimul nod din lista. Am ales sa reprezint asa deoarece mi s-a parut mai usor si mai eficient in cazul operatiilor de adaugare/stergere.

Am intampinat probleme la pasarea parametrilor in C. Desi stiam ca in C parametrii sunt pasati prin valoarea (chiar daca sunt pointer) , am pierdut ceva timp sa inteleg de unde aparea o eroare de dezalocare a tabelei. 
Nu am inteles totusi de ce desi alocam memorie pt o noua table (ie. in table_rezice_double) si intorceam un pointer la acea zona de memorie, in functia apelanta, pointerul caruia ii era atribuit valoarea (read_input(...)) nu o mai pastra atunci cand revenea in main. Precizez ca in main apelam functia (read_input(&tabela)).

In cele din urma am ales sa nu mai aloc pe heap memorie pentru tabel, ci pe stack. In stadiul acesta al programului cred ca ar fi fost bine sa folosesc niste unit tests pentru a putea face debugging mai usor.


